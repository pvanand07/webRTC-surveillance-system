<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Recorder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-base: #0a0a0b;
            --bg-elevated: #141416;
            --bg-card: #1a1a1d;
            --bg-hover: #222226;
            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-strong: rgba(255, 255, 255, 0.12);
            --text-primary: #f5f5f7;
            --text-secondary: #a1a1a6;
            --text-tertiary: #6e6e73;
            --accent-red: #ff3b30;
            --accent-red-dim: #ff6b6b;
            --accent-green: #30d158;
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 20px;
            --radius-full: 9999px;
            --ease-apple: cubic-bezier(0.25, 0.1, 0.25, 1);
            --shadow-soft: 0 2px 8px rgba(0, 0, 0, 0.35);
            --shadow-modal: 0 24px 48px -12px rgba(0, 0, 0, 0.6);
        }

        * { -webkit-tap-highlight-color: transparent; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'SF Pro Display', 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-base);
            color: var(--text-primary);
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        [v-cloak] { display: none; }

        /* Pulsing red dot – recording indicator */
        .rec-pulse {
            animation: rec-pulse 1.4s ease-in-out infinite;
        }
        @keyframes rec-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.05); }
        }

        /* Clip cards – lift and glow on hover */
        .clip-card {
            transition: transform 0.2s var(--ease-apple), box-shadow 0.2s var(--ease-apple), background 0.2s var(--ease-apple);
        }
        .clip-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-soft);
            background: var(--bg-hover);
        }
        .clip-card:active {
            transform: translateY(0);
        }

        /* Minimal scrollbar */
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: var(--radius-full);
        }
        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        /* Modal – vibrancy backdrop */
        .modal-backdrop {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: saturate(180%) blur(20px);
            -webkit-backdrop-filter: saturate(180%) blur(20px);
            animation: fadeIn 0.25s var(--ease-apple);
        }
        .modal-panel {
            animation: scaleIn 0.3s var(--ease-apple);
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes scaleIn {
            from { opacity: 0; transform: scale(0.96); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Primary button – press feedback */
        .btn-record {
            transition: transform 0.15s var(--ease-apple), box-shadow 0.2s var(--ease-apple), background 0.2s var(--ease-apple);
        }
        .btn-record:hover:not(:disabled) {
            transform: scale(1.02);
        }
        .btn-record:active:not(:disabled) {
            transform: scale(0.98);
        }

        .clip-delete-btn:hover {
            color: var(--accent-red) !important;
            background: var(--bg-hover);
        }

        .modal-close-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
    </style>
</head>
<body>

<div id="app" v-cloak class="flex h-screen overflow-hidden">

    <!-- MAIN AREA -->
    <div class="flex-1 flex flex-col min-w-0">

        <!-- Header – subtle bar with vibrancy -->
        <header class="flex items-center justify-between px-6 py-3.5 border-b border-[var(--border-subtle)]"
                style="background: var(--bg-elevated);">
            <div class="flex items-center gap-3">
                <div class="w-9 h-9 rounded-[var(--radius-md)] flex items-center justify-center"
                     style="background: linear-gradient(145deg, var(--accent-red) 0%, #e6352e 100%); box-shadow: 0 2px 8px rgba(255,59,48,0.35);">
                    <svg class="w-5 h-5 text-white drop-shadow-sm" fill="currentColor" viewBox="0 0 20 20">
                        <circle cx="10" cy="10" r="6"/>
                    </svg>
                </div>
                <h1 class="text-[17px] font-semibold tracking-tight" style="color: var(--text-primary);">Simple Recorder</h1>
            </div>
            <div class="flex items-center gap-2.5 text-[13px] font-medium" style="color: var(--text-secondary);">
                <span class="flex items-center gap-2 px-3 py-1.5 rounded-[var(--radius-full)]"
                      style="background: rgba(255,255,255,0.06);">
                    <span class="w-2 h-2 rounded-full flex-shrink-0"
                          :style="{ background: connected ? 'var(--accent-green)' : 'var(--accent-red)' }"></span>
                    {{ connected ? 'Connected' : 'Disconnected' }}
                </span>
            </div>
        </header>

        <!-- Video Area -->
        <div class="flex-1 flex items-center justify-center p-8" style="background: var(--bg-base);">
            <div class="relative w-full max-w-3xl aspect-video overflow-hidden rounded-[var(--radius-xl)]"
                 style="background: #000; box-shadow: var(--shadow-soft), 0 0 0 1px var(--border-subtle);">

                <!-- Live video -->
                <video ref="liveVideo" autoplay playsinline muted
                       class="w-full h-full object-contain bg-black"></video>

                <!-- Recording overlay – pill with blur -->
                <div v-if="recording || postrolling"
                     class="absolute top-5 left-5 flex items-center gap-2.5 rounded-[var(--radius-full)] px-4 py-2"
                     style="background: rgba(0,0,0,0.5); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.08);">
                    <span class="w-2.5 h-2.5 rounded-full rec-pulse" style="background: var(--accent-red);"></span>
                    <span class="text-[13px] font-semibold tracking-wide" style="color: var(--accent-red-dim);" v-if="recording">
                        REC {{ recordingTime }}
                    </span>
                    <span class="text-[13px] font-semibold" style="color: #ff9f0a;" v-else-if="postrolling">
                        Saving… {{ postrollCountdown }}s
                    </span>
                </div>

                <!-- No camera fallback -->
                <div v-if="!connected"
                     class="absolute inset-0 flex items-center justify-center" style="color: var(--text-tertiary);">
                    <div class="text-center">
                        <svg class="w-14 h-14 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                  d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                        </svg>
                        <p class="text-[15px] font-medium">Connecting to camera…</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls – single primary action -->
        <div class="flex items-center justify-center gap-4 px-6 py-6 border-t border-[var(--border-subtle)]"
             style="background: var(--bg-elevated);">
            <button @click="toggleRecording"
                    :disabled="postrolling"
                    class="btn-record flex items-center gap-3 px-8 py-3.5 rounded-[var(--radius-full)] font-semibold text-[15px] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-[var(--bg-elevated)] disabled:cursor-not-allowed"
                    :class="recording
                        ? 'text-white focus:ring-[var(--accent-red)]'
                        : postrolling
                            ? 'cursor-not-allowed'
                            : 'text-[var(--bg-base)] focus:ring-white'"
                    :style="recording
                        ? 'background: linear-gradient(180deg, var(--accent-red) 0%, #e6352e 100%); box-shadow: 0 4px 14px rgba(255,59,48,0.4);'
                        : postrolling
                            ? 'background: var(--bg-card); color: var(--text-tertiary);'
                            : 'background: #fff; box-shadow: 0 2px 8px rgba(0,0,0,0.25);'">
                <template v-if="!recording && !postrolling">
                    <span class="w-5 h-5 rounded-full flex-shrink-0" style="background: var(--accent-red);"></span>
                    <span>Start Recording</span>
                </template>
                <template v-else-if="recording">
                    <svg class="w-5 h-5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                        <rect x="5" y="5" width="10" height="10" rx="2"/>
                    </svg>
                    <span>Stop Recording</span>
                </template>
                <template v-else>
                    <svg class="w-5 h-5 flex-shrink-0 animate-spin" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"/>
                        <path class="opacity-75" fill="currentColor"
                              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"/>
                    </svg>
                    <span>Saving…</span>
                </template>
            </button>
        </div>
    </div>

    <!-- SIDEBAR – Recorded Clips -->
    <aside class="w-80 flex-shrink-0 flex flex-col border-l border-[var(--border-subtle)]"
           style="background: var(--bg-elevated);">

        <!-- Sidebar header -->
        <div class="flex items-center justify-between px-5 py-3.5 border-b border-[var(--border-subtle)]">
            <h2 class="text-[13px] font-semibold uppercase tracking-wider" style="color: var(--text-secondary);">Recordings</h2>
            <span class="text-[12px] font-medium tabular-nums" style="color: var(--text-tertiary);">{{ clips.length }} clip{{ clips.length !== 1 ? 's' : '' }}</span>
        </div>

        <!-- Clips list -->
        <div class="flex-1 overflow-y-auto custom-scroll p-3 space-y-2.5" v-if="clips.length">
            <div v-for="clip in clips" :key="clip.clip_id"
                 class="group clip-card rounded-[var(--radius-md)] overflow-hidden cursor-pointer"
                 style="background: var(--bg-card); border: 1px solid var(--border-subtle);"
                 @click="playClip(clip)">

                <!-- Thumbnail -->
                <div class="relative aspect-video overflow-hidden" style="background: var(--bg-base);">
                    <img v-if="clip.thumbnail_url"
                         :src="clip.thumbnail_url"
                         class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-[1.02]"
                         alt="thumbnail"
                         loading="lazy"/>
                    <div v-else class="w-full h-full flex items-center justify-center" style="color: var(--text-tertiary);">
                        <svg class="w-10 h-10" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                  d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
                            <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                        </svg>
                    </div>

                    <!-- Play overlay -->
                    <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-200"
                         style="background: rgba(0,0,0,0.4);">
                        <div class="w-12 h-12 rounded-full flex items-center justify-center shadow-lg"
                             style="background: rgba(255,255,255,0.95);">
                            <svg class="w-6 h-6 ml-0.5" style="color: var(--bg-base);" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M6.3 2.841A1.5 1.5 0 004 4.11v11.78a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z"/>
                            </svg>
                        </div>
                    </div>
                </div>

                <!-- Info -->
                <div class="px-3 py-2.5 flex items-center justify-between gap-2">
                    <div class="min-w-0 flex-1">
                        <p class="text-[13px] font-medium truncate" style="color: var(--text-primary);">{{ formatDate(clip.created) }}</p>
                        <p class="text-[12px] mt-0.5" style="color: var(--text-tertiary);">{{ formatSize(clip.size_bytes) }}</p>
                    </div>
                    <button @click.stop="deleteClip(clip.clip_id)"
                            class="clip-delete-btn p-2 rounded-[var(--radius-sm)] transition-colors duration-150 flex-shrink-0"
                            style="color: var(--text-tertiary);"
                            title="Delete clip">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                  d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Empty state -->
        <div v-else class="flex-1 flex items-center justify-center text-center p-8">
            <div>
                <svg class="w-14 h-14 mx-auto mb-4 opacity-40" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"
                     style="color: var(--text-tertiary);">
                    <path stroke-linecap="round" stroke-linejoin="round"
                          d="M7 4v16M17 4v16M3 8h4m10 0h4M3 12h18M3 16h4m10 0h4M4 20h16a1 1 0 001-1V5a1 1 0 00-1-1H4a1 1 0 00-1 1v14a1 1 0 001 1z"/>
                </svg>
                <p class="text-[15px] font-medium" style="color: var(--text-secondary);">No recordings yet</p>
                <p class="text-[13px] mt-1" style="color: var(--text-tertiary);">Press record to capture a clip</p>
            </div>
        </div>
    </aside>

    <!-- MODAL – Clip Player -->
    <div v-if="playerClip"
         class="fixed inset-0 z-50 modal-backdrop flex items-center justify-center p-6"
         @click.self="closePlayer">
        <div class="modal-panel w-full max-w-3xl overflow-hidden rounded-[var(--radius-xl)] border border-[var(--border-subtle)]"
             style="background: var(--bg-elevated); box-shadow: var(--shadow-modal);">
            <!-- Modal header -->
            <div class="flex items-center justify-between px-5 py-4 border-b border-[var(--border-subtle)]">
                <div>
                    <p class="text-[15px] font-semibold" style="color: var(--text-primary);">{{ formatDate(playerClip.created) }}</p>
                    <p class="text-[13px] mt-0.5" style="color: var(--text-tertiary);">{{ formatSize(playerClip.size_bytes) }}</p>
                </div>
                <button @click="closePlayer"
                        class="modal-close-btn p-2.5 rounded-[var(--radius-md)] transition-colors duration-150"
                        style="color: var(--text-secondary);">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <!-- Video -->
            <div class="aspect-video bg-black">
                <video ref="playerVideo"
                       :src="playerClip.video_url"
                       controls autoplay
                       class="w-full h-full object-contain">
                </video>
            </div>
        </div>
    </div>

</div>

<script>
const { createApp, ref, onMounted, onBeforeUnmount, nextTick } = Vue;

createApp({
    setup() {
        // Refs
        const liveVideo = ref(null);
        const playerVideo = ref(null);

        // State
        const connected = ref(false);
        const recording = ref(false);
        const postrolling = ref(false);
        const postrollCountdown = ref(0);
        const recordingTime = ref('00:00');
        const clips = ref([]);
        const playerClip = ref(null);

        let pc = null;
        let ws = null;
        let recordingTimer = null;
        let recordingStart = 0;
        let postrollTimer = null;

        // --------------------------------------------------------
        // WebRTC
        // --------------------------------------------------------
        async function connectWebRTC() {
            try {
                pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
                });

                pc.ontrack = (ev) => {
                    if (liveVideo.value) {
                        liveVideo.value.srcObject = ev.streams[0];
                    }
                    connected.value = true;
                };

                pc.onconnectionstatechange = () => {
                    if (pc.connectionState === 'connected') {
                        connected.value = true;
                    } else if (['failed', 'closed', 'disconnected'].includes(pc.connectionState)) {
                        connected.value = false;
                    }
                };

                // We need a transceiver to receive video
                pc.addTransceiver('video', { direction: 'recvonly' });

                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                const resp = await fetch('/offer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sdp: pc.localDescription.sdp,
                        type: pc.localDescription.type,
                    }),
                });

                const answer = await resp.json();
                await pc.setRemoteDescription(answer);
            } catch (err) {
                console.error('WebRTC error:', err);
                connected.value = false;
                // Retry after a delay
                setTimeout(connectWebRTC, 3000);
            }
        }

        // --------------------------------------------------------
        // WebSocket for status updates
        // --------------------------------------------------------
        function connectWS() {
            const proto = location.protocol === 'https:' ? 'wss' : 'ws';
            ws = new WebSocket(`${proto}://${location.host}/ws/status`);

            ws.onmessage = (ev) => {
                const msg = JSON.parse(ev.data);
                handleStatusMsg(msg);
            };

            ws.onclose = () => {
                setTimeout(connectWS, 2000);
            };
        }

        function handleStatusMsg(msg) {
            switch (msg.type) {
                case 'recording_started':
                    recording.value = true;
                    postrolling.value = false;
                    startRecordingTimer();
                    break;

                case 'postroll_started':
                    recording.value = false;
                    postrolling.value = true;
                    stopRecordingTimer();
                    startPostrollCountdown(msg.seconds || 5);
                    break;

                case 'recording_saved':
                    postrolling.value = false;
                    stopPostrollCountdown();
                    if (msg.clip) {
                        // Prepend to clips list
                        clips.value.unshift(msg.clip);
                    } else {
                        fetchClips();
                    }
                    break;

                case 'clip_deleted':
                    clips.value = clips.value.filter(c => c.clip_id !== msg.clip_id);
                    break;
            }
        }

        // --------------------------------------------------------
        // Recording controls
        // --------------------------------------------------------
        async function toggleRecording() {
            if (postrolling.value) return;

            if (recording.value) {
                // Stop
                await fetch('/api/recording/stop', { method: 'POST' });
            } else {
                // Start
                await fetch('/api/recording/start', { method: 'POST' });
            }
        }

        function startRecordingTimer() {
            recordingStart = Date.now();
            recordingTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recordingStart) / 1000);
                const m = String(Math.floor(elapsed / 60)).padStart(2, '0');
                const s = String(elapsed % 60).padStart(2, '0');
                recordingTime.value = `${m}:${s}`;
            }, 250);
        }

        function stopRecordingTimer() {
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
            recordingTime.value = '00:00';
        }

        function startPostrollCountdown(seconds) {
            postrollCountdown.value = seconds;
            postrollTimer = setInterval(() => {
                postrollCountdown.value = Math.max(0, postrollCountdown.value - 1);
                if (postrollCountdown.value <= 0) {
                    stopPostrollCountdown();
                }
            }, 1000);
        }

        function stopPostrollCountdown() {
            if (postrollTimer) {
                clearInterval(postrollTimer);
                postrollTimer = null;
            }
        }

        // --------------------------------------------------------
        // Clips
        // --------------------------------------------------------
        async function fetchClips() {
            try {
                const resp = await fetch('/api/clips');
                const data = await resp.json();
                clips.value = data.clips || [];
            } catch (err) {
                console.error('Failed to fetch clips:', err);
            }
        }

        function playClip(clip) {
            playerClip.value = clip;
        }

        function closePlayer() {
            if (playerVideo.value) {
                playerVideo.value.pause();
            }
            playerClip.value = null;
        }

        async function deleteClip(clipId) {
            if (!confirm('Delete this recording?')) return;
            try {
                await fetch(`/api/clips/${clipId}`, { method: 'DELETE' });
                clips.value = clips.value.filter(c => c.clip_id !== clipId);
                if (playerClip.value && playerClip.value.clip_id === clipId) {
                    closePlayer();
                }
            } catch (err) {
                console.error('Delete failed:', err);
            }
        }

        // --------------------------------------------------------
        // Formatting helpers
        // --------------------------------------------------------
        function formatDate(iso) {
            if (!iso) return '';
            const d = new Date(iso);
            return d.toLocaleString(undefined, {
                month: 'short', day: 'numeric',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
            });
        }

        function formatSize(bytes) {
            if (!bytes) return '';
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // --------------------------------------------------------
        // Keyboard shortcuts
        // --------------------------------------------------------
        function onKeydown(e) {
            // Space bar toggles recording (when not in modal)
            if (e.code === 'Space' && !playerClip.value) {
                e.preventDefault();
                toggleRecording();
            }
            // Escape closes modal
            if (e.code === 'Escape' && playerClip.value) {
                closePlayer();
            }
        }

        // --------------------------------------------------------
        // Lifecycle
        // --------------------------------------------------------
        onMounted(() => {
            connectWebRTC();
            connectWS();
            fetchClips();

            // Also poll recording status on load
            fetch('/api/recording/status')
                .then(r => r.json())
                .then(data => {
                    recording.value = data.is_recording;
                    postrolling.value = data.postroll_active;
                    if (data.is_recording) startRecordingTimer();
                })
                .catch(() => {});

            window.addEventListener('keydown', onKeydown);
        });

        onBeforeUnmount(() => {
            stopRecordingTimer();
            stopPostrollCountdown();
            if (pc) pc.close();
            if (ws) ws.close();
            window.removeEventListener('keydown', onKeydown);
        });

        return {
            liveVideo, playerVideo,
            connected, recording, postrolling,
            postrollCountdown, recordingTime,
            clips, playerClip,
            toggleRecording, playClip, closePlayer, deleteClip,
            formatDate, formatSize,
        };
    }
}).mount('#app');
</script>
</body>
</html>
